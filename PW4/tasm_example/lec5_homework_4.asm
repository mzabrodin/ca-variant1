;4. Скопіювати код задачі 3. Додати до функції код, що (А) перед виконанням функції зберігає регістри,
;які змінює функція, у стек і (Б) після виконання розрахунків повертає їх зі стеку.
;Мета: забезпечили щоб функція під час свого виконання не змінювала регістри коду, що її викликає.

.model small
.stack 100h

.code
main PROC
    push ax         ; (A) Збережемо значення регістрів, які можуть бути змінені в функції
    push bx
    push 20         ; 2nd argument
    push 18         ; 1st argument
    call find_maximum

    ; Після виконання функції витягуємо значення зі стеку
    pop bx
    pop ax

    mov ax, 4C00h   ; Завершуємо програму
    int 21h
main ENDP

find_maximum PROC
    push bp         ; (A) Збережемо регістр бази стеку
    mov bp, sp      ; (A) Встановимо базу стекового фрейму

    push bx         ; (A) Збережемо значення регістру BX

    mov bx, [bp+6]  ; (A) Отримаємо перший аргумент
    mov ax, [bp+8]  ; (A) Отримаємо другий аргумент

    cmp ax, bx      ; Порівняємо значення AX та BX
    jge greater     ; Переходимо до мітки "greater", якщо AX >= BX
    mov ax, bx      ; Якщо не виконується умова, AX містить менше число, тому замінюємо його на BX
    jmp end_find_maximum

greater:
    ; AX вже містить більше число, тому нічого не потрібно робити

end_find_maximum:
    pop bx          ; (A) Відновлюємо значення регістру BX

    pop bp          ; (A) Відновлюємо значення регістру бази стеку

    ret 4           ; (Б) Виконуємо повернення та видаляємо 2 аргументи (4 байти) зі стеку
find_maximum ENDP

end main

